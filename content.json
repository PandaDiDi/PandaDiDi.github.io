{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-12T08:01:00.877Z","updated":"2021-07-12T08:01:00.877Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-12T08:01:00.877Z","updated":"2021-07-12T08:01:00.877Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-07-12T08:01:00.877Z","updated":"2021-07-12T08:01:00.877Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-12T08:01:00.877Z","updated":"2021-07-12T08:01:00.877Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-12T08:01:00.877Z","updated":"2021-07-12T08:01:00.877Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-12T08:01:00.877Z","updated":"2021-07-12T08:01:00.877Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-12T08:01:00.893Z","updated":"2021-07-12T08:01:00.893Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"排序","slug":"排序","date":"2021-07-20T11:08:55.000Z","updated":"2021-07-20T11:09:56.205Z","comments":true,"path":"2021/07/20/排序/","link":"","permalink":"http://example.com/2021/07/20/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"常用排序算法面试中经常会被问到或现场写：冒泡、快速 （1）冒泡排序 Bubble Sort ```java/** 冒泡排序 @param arr 需要排序的数组*/public void bubbleSort(int[] arr){for(int i= 0;i&lt;arr.length;i++){for(int j = 0;j&lt;arr.length-i-1;j++)&#123; if(arr[j] &gt; arr[j+1])&#123; int temp; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.print(arr[i] + &quot;,&quot;); }}123456789101112131415161718192021222324252627282930313233343536373839404142434445----------#### （2）插入排序 Insert Sort ```java /** - 插入排序 - @param arr 需要排序的数组 */ public static void insertSort(int[] arr)&#123; int length=arr.length; //数组长度 int j; //当前值的位置 int i; //指向j前的位置 int key; //当前要进行插入排序的值 //61,19,56,37,20 ,66,50,34,37,3 // 19 37 56 61 20 /* key = 20 j =4; i = j-1 = 3 a[4] = a[3] 19 37 56 61 61 i = 2 56 &gt; 20 a[3]=a[2] 19 37 56 56 61 i = 1 37 &gt; 20 a[2] = a[1] 19 37 37 56 61 i =0 19 &gt; 20 false a[1] = key =20 */ //从数组的第二个位置开始遍历值 19 37 56 61 20 for(j=1;j&lt;length;j++)&#123; key=arr[j]; i=j-1; //a[i]比当前值大时，a[i]后移一位,空出i的位置，好让下一次循环的值后移 while(i&gt;=0 &amp;&amp; arr[i]&gt;key)&#123; arr[i+1]=arr[i]; //将a[i]值后移 i--; //i前移 &#125;//跳出循环(找到要插入的中间位置或已遍历到0下标) arr[i+1]=key; //将当前值插入 &#125; &#125; （3）选择排序 Select Sort12345678910111213141516171819/**- 选择排序 - @param arr 需要排序的数组 */ public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; int min = i; // 将当前下标定义为最小值下标 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) &#123; /* 如果有小于当前最小值的关键字 */ min = j; /* 将此关键字的下标赋值给min */ &#125; &#125; if (i != min) &#123;/* 若min不等于i，说明找到最小值，交换 */ int tmp = arr[min]; arr[min] = arr[i]; arr[i] = tmp; &#125; &#125; &#125; （4）归并排序 Merge Sort123456789101112131415161718192021222324252627282930313233343536/** - 归并排序 - @param a 需要排序的数组 - @param s 第一个有序表的起始下标 - @param m 第二个有序表的起始下标 - @param t 第二个有序表的结束下标 - */ public static void merge(int[] arr, int s, int m, int t) &#123; int[] tmp = new int[t - s + 1]; int i = s, j = m, k = 0; while (i &lt; m &amp;&amp; j &lt;= t) &#123; if (arr[i] &lt;= arr[j]) &#123; tmp[k] = arr[i]; k++; i++; &#125; else &#123; tmp[k] = arr[j]; // sum += (j - i) - (j - m); j++; k++; &#125; &#125; while (i &lt; m) &#123; tmp[k] = arr[i]; i++; k++; &#125; while (j &lt;= t) &#123; tmp[k] = arr[j]; j++; k++; &#125; System.arraycopy(tmp, 0, arr, s, tmp.length); &#125; （5）快速排序 Quick Sort1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /** * 获得基础的下标 * @param arr 需要排序的数组 * @param low 数组待排序的最小的下标 * @param high 数组待排序的最大的下标 * @return 返回中轴值（该值大于左边值，小于右边值） */ public static int getMiddle(int[] arr,int low,int high)&#123; int temp = arr[low];// temp = 67 // 67，23，12，11，56，87，23，48，22，18 // 18，23，12，11，56，87，23，48，22，18 // 18，23，12，11，56，87，23，48，22，87 // 18，23，12，11，56，22，23，48，22，87 // 18，23，12，11，56，22，23，48，67，87 while(low &lt;high)&#123;// 0&lt;1 while(low &lt;high &amp;&amp; arr[high] &gt; temp)&#123;//0&lt;1 &amp;&amp; 14&gt;12 high--;//h = 0 &#125; arr[low] = arr[high]; // a[0] = a[0]; while(low &lt;high &amp;&amp; arr[low] &lt;=temp)&#123;// low++; &#125; arr[high] = arr[low];//a[0] = a[0] &#125; arr[low] = temp;//a[0] = 12 return low;// 8 &#125; public static void quickSort(int[] arr,int low, int high)&#123; if(low &lt;high)&#123;//0,1 //将数组一份为二 int middle = getMiddle(arr, low, high);// arr 0,9 m = 8 System.out.println(&quot;middle = &quot; + middle);//m =4 //左边进行递归 快速排序 quickSort(arr,low,middle -1); // arr 0,7 //右边进行递归 快速排序 quickSort(arr,middle + 1,high);// arr 9，9 &#125;&#125;//再次封装，对外调用 12，14public static void quick(int[] arr)&#123; if(arr.length &gt;=2) quickSort(arr, 0, arr.length -1);// 0,9&#125;int[] a =&#123;&#125;int[] a =&#123;65&#125;int[] a =&#123;65,16&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://example.com/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"}]},{"title":"面向对象","slug":"面向对象","date":"2021-07-20T11:06:00.000Z","updated":"2021-07-20T11:08:36.860Z","comments":true,"path":"2021/07/20/面向对象/","link":"","permalink":"http://example.com/2021/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"一、方法重载 overload语法123451. 方法名相同2. 参数列表不一样 a. 个数不一样 b. 类型不一样 c. 顺序不一样 理解：12调用某一方法的时候，发现该方法的参数列表不满足需求，那么就需要重新创建同名的方法，参数列表不一样 =====&gt; 即实现 【方法重载】 示例一：12345678910111213141516171819202122232425262728293031323334 public int add(int x,int y)&#123; return x+y; &#125; public int add(int x,int y,int z)&#123; return x+y +z; &#125; public double add(double x,double y)&#123; return x+y; &#125; public double add(int x,double y)&#123; return x+y; &#125; public double add(double x,int y)&#123; return x+y; &#125; public double add(float x)&#123; return x; &#125; public void add(char x)&#123; &#125; public void add(int x)&#123; &#125;//add方法调用 computer1.add(10,20); computer1.add(10,30.7); computer1.add(&#x27;a&#x27;); computer1.add(10,20,30); 构造函数也构成方法重载 1234567public Computer()&#123;&#125;public Computer(String computerBrand, String computerColor, double computerWeight) &#123; this.computerBrand = computerBrand; this.computerColor = computerColor; this.computerWeight = computerWeight;&#125; 二、 构造函数 Constructor作用：初始化对象语法：无参构造函数 （默认隐藏）有参构造函数注意： ``` 无参构造函数 默认隐藏 有了有参构造函数，默认会把无参构造函数 覆盖掉， 若还想调用 无参构造函数，则 必须把 无参构造函数 显式的写出来123456789101112 #### 示例：```javapublic class Computer &#123; public Computer()&#123;...&#125; // 无参构造函数 （默认隐藏） public Computer(String computerBrand)&#123;...&#125; //有参构造函数 public Computer(String computerBrand, String computerColor)&#123;...&#125; //有参构造函数 public Computer(String computerBrand, String computerColor, double computerWeight)&#123;...&#125; //有参构造函数&#125; 创建对象的内存实现过程(1) 通过无参构造函数 实例化 对象12345678910111213141516171819public class Computer &#123; private String computerBrand ;//电脑品牌名称 private String computerColor; //电脑颜色 private double computerWeight;//电脑重量 //默认隐藏 构造函数 Constructor //无参构造函数 public Computer()&#123;&#125;&#125;//测试类public class ComputerTest &#123; public static void main(String[] args) &#123; Computer computer1 = new Computer(); // new : 创建对象，在堆开辟一块内存 // Computer() ： 调用无参构造函数 &#125;&#125; （2）通过有参构造函数 实例化 对象123456789101112131415161718192021222324public class Computer &#123; private String computerBrand ;//电脑品牌名称 private String computerColor; //电脑颜色 private double computerWeight;//电脑重量 //默认隐藏 构造函数 Constructor //无参构造函数 public Computer()&#123;&#125; public Computer(String computerBrand, String computerColor, double computerWeight) &#123; this.computerBrand = computerBrand; this.computerColor = computerColor; this.computerWeight = computerWeight; &#125;&#125;//测试类public class ComputerTest &#123; public static void main(String[] args) &#123; Computer computer2= new Computer(&quot;ThinkPad&quot;,&quot;White&quot;,49.9); &#125;&#125; 面向对象编程OOP :Object Oriented Programming1. 类与对象12类： 是群体性概念，描述一类事物共有的属性与行为对象：是类在现实生活中 一个个实实在在的个体 示例：1234567891011121314151617181920212223/** 用于描述学生信息 * 学生共有的属性与行为*/public class Student&#123; /** * 学生姓名 */ public String sname; /** * 学生手机号 */ public long stuTelno; /** * 学生年龄 */ public int studentAge; /** * 学生专业 */ public String studentMajor; &#125; StudentTest12345678910111213141516171819202122232425public class StudentTest &#123; public static void main(String[] args) &#123; //描述我与同桌两个学生个体 //创建学生对象 //数据类型 变量名 = 值; int a = 10; //数据类型 对象名 = 值; Student student1 = new Student(); student1.studentName = &quot;SunShenshen&quot;; student1.studentAge = 20; student1.studentMajor=&quot;计算机&quot;; student1.studentTelno = 184398404L; Student student2 = new Student(); student2.studentName = &quot;LiuBaohe&quot;; student2.studentAge = 21; student2.studentMajor = &quot;计算机&quot;; student2.studentTelno = 184934893L; System.out.println(student2.studentMajor); &#125; &#125; 内存分配图 （重点） 存在的问题12耦合性较高、可维护性比较差 ： 修改Student成员变量名，其他类中的属性 也要修改安全性较低： Student类的元信息（属性）暴露出去 解决：1234561. 访问权限* public ： 公共的，所有的类都能访问* private : 私有的， 只有本类能访问 2.set 方法 给属性赋值 get 方法 获得属性值 Student1234567891011121314151617181920212223242526272829303132333435363738public class Student &#123; /** * 学生姓名 */ private String sname; /** * 学生手机号 */ private long stuTelno; /** * 学生年龄 */ private int studentAge; /** * 学生专业 */ private String studentMajor; //给学生姓名赋值 public void setStuName(String name)&#123; sname = name; &#125; //给学生年龄赋值 public void setStudentAge(int age)&#123; studentAge = age; &#125; //给学生手机号赋值 public void setStudentTelno(long telno)&#123; stuTelno = telno; &#125; //给学生专业赋值 public void setStudentMajor(String major)&#123; studentMajor = major; &#125;&#125; StudentTest123456789101112 Student student1 = new Student(); student1.setStuName(&quot;SunShenshen&quot;); student1.setStudentAge(20); student1.setStudentMajor(&quot;计算机&quot;); student1.setStudentTelno(138938493493L);/* public void setStuName(String name)&#123; stuName = name; // 等价于 student =name = &quot;SunShenshen&quot; &#125; */ 语法： 12345678910创建对象// 类类型 Student s1 = new Student();类类型 对象名 = new 类类型(); //访问对象的属性 s1.studentName = &quot;Tom&quot; 对象名.属性名 //访问对象的方法 s1.setName(&quot;Tom&quot;) 对象名.方法名 封装​ 数据的安全性、耦合性 ​ 具体体现: 访问权限（public - private ） ​ set 、get this关键字123this : 当前对象this.属性 // 当前对象的某一个属性this.方法 // 当前对象的方法 方法1234567891011121314151617结构访问权限 + [static | final] + 返回值 + 方法名 + 参数列表 + 异常 + 方法体目前需要掌握的：访问权限 + 返回值 + 方法名 + 参数列表 + 方法体public class Student&#123; public int getAge()&#123; &#125; public void setAge(int age)&#123; // age 形式参数（形参），作用域范围 就当前方法 &#125;&#125; Student stu = new Student();stu.setAge(10); //实际参数，实参 面向对象再次理解12345678910111213141516171819202122232425262728293031323334353637public class Phone&#123; private String phoneName;//手机名称 private float phonePrice;//手机价格 //set get //打电话 public void call()&#123; &#125;&#125;public class PhineTest&#123; public static void main(String[] args)&#123; // 手机所有的参数信息 都是从 手机对象 身上获得的 Phone p1 = new Phone(); p1.setPhoneName(&quot;Huawei P30&quot;); p1.setPhonePrice(4288); String pname = p1.getPhoneName(); float pprice = p1.getPhonePrice(); p1.call(); // 这个p1 华为手机 调用 打电话功能 对象的行为 Phone p2 = new Phone(); p2.setPhoneName(&quot;Iphone X&quot;); p2.setPhonePrice(5288); String pname = p2.getPhoneName(); float pprice = p2.getPhonePrice(); p2.call(); // 这个p2 iphone手机 调用 打电话功能 对象的行为 &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://example.com/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"}]},{"title":"正式课程2","slug":"正式课程2","date":"2021-07-19T12:24:40.000Z","updated":"2021-07-19T12:44:44.578Z","comments":true,"path":"2021/07/19/正式课程2/","link":"","permalink":"http://example.com/2021/07/19/%E6%AD%A3%E5%BC%8F%E8%AF%BE%E7%A8%8B2/","excerpt":"","text":"常用排序算法面试中经常会被问到或现场写：冒泡、快速 （1）冒泡排序 Bubble Sort ```java/** 冒泡排序 @param arr 需要排序的数组*/public void bubbleSort(int[] arr){for(int i= 0;i&lt;arr.length;i++){for(int j = 0;j&lt;arr.length-i-1;j++)&#123; if(arr[j] &gt; arr[j+1])&#123; int temp; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.print(arr[i] + &quot;,&quot;); }}123456789101112131415161718192021222324252627282930313233343536373839404142434445----------#### （2）插入排序 Insert Sort ```java /** - 插入排序 - @param arr 需要排序的数组 */ public static void insertSort(int[] arr)&#123; int length=arr.length; //数组长度 int j; //当前值的位置 int i; //指向j前的位置 int key; //当前要进行插入排序的值 //61,19,56,37,20 ,66,50,34,37,3 // 19 37 56 61 20 /* key = 20 j =4; i = j-1 = 3 a[4] = a[3] 19 37 56 61 61 i = 2 56 &gt; 20 a[3]=a[2] 19 37 56 56 61 i = 1 37 &gt; 20 a[2] = a[1] 19 37 37 56 61 i =0 19 &gt; 20 false a[1] = key =20 */ //从数组的第二个位置开始遍历值 19 37 56 61 20 for(j=1;j&lt;length;j++)&#123; key=arr[j]; i=j-1; //a[i]比当前值大时，a[i]后移一位,空出i的位置，好让下一次循环的值后移 while(i&gt;=0 &amp;&amp; arr[i]&gt;key)&#123; arr[i+1]=arr[i]; //将a[i]值后移 i--; //i前移 &#125;//跳出循环(找到要插入的中间位置或已遍历到0下标) arr[i+1]=key; //将当前值插入 &#125; &#125; （3）选择排序 Select Sort12345678910111213141516171819/**- 选择排序 - @param arr 需要排序的数组 */ public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; int min = i; // 将当前下标定义为最小值下标 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) &#123; /* 如果有小于当前最小值的关键字 */ min = j; /* 将此关键字的下标赋值给min */ &#125; &#125; if (i != min) &#123;/* 若min不等于i，说明找到最小值，交换 */ int tmp = arr[min]; arr[min] = arr[i]; arr[i] = tmp; &#125; &#125; &#125; （4）归并排序 Merge Sort123456789101112131415161718192021222324252627282930313233343536/** - 归并排序 - @param a 需要排序的数组 - @param s 第一个有序表的起始下标 - @param m 第二个有序表的起始下标 - @param t 第二个有序表的结束下标 - */ public static void merge(int[] arr, int s, int m, int t) &#123; int[] tmp = new int[t - s + 1]; int i = s, j = m, k = 0; while (i &lt; m &amp;&amp; j &lt;= t) &#123; if (arr[i] &lt;= arr[j]) &#123; tmp[k] = arr[i]; k++; i++; &#125; else &#123; tmp[k] = arr[j]; // sum += (j - i) - (j - m); j++; k++; &#125; &#125; while (i &lt; m) &#123; tmp[k] = arr[i]; i++; k++; &#125; while (j &lt;= t) &#123; tmp[k] = arr[j]; j++; k++; &#125; System.arraycopy(tmp, 0, arr, s, tmp.length); &#125; （5）快速排序 Quick Sort1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /** * 获得基础的下标 * @param arr 需要排序的数组 * @param low 数组待排序的最小的下标 * @param high 数组待排序的最大的下标 * @return 返回中轴值（该值大于左边值，小于右边值） */ public static int getMiddle(int[] arr,int low,int high)&#123; int temp = arr[low];// temp = 67 // 67，23，12，11，56，87，23，48，22，18 // 18，23，12，11，56，87，23，48，22，18 // 18，23，12，11，56，87，23，48，22，87 // 18，23，12，11，56，22，23，48，22，87 // 18，23，12，11，56，22，23，48，67，87 while(low &lt;high)&#123;// 0&lt;1 while(low &lt;high &amp;&amp; arr[high] &gt; temp)&#123;//0&lt;1 &amp;&amp; 14&gt;12 high--;//h = 0 &#125; arr[low] = arr[high]; // a[0] = a[0]; while(low &lt;high &amp;&amp; arr[low] &lt;=temp)&#123;// low++; &#125; arr[high] = arr[low];//a[0] = a[0] &#125; arr[low] = temp;//a[0] = 12 return low;// 8 &#125; public static void quickSort(int[] arr,int low, int high)&#123; if(low &lt;high)&#123;//0,1 //将数组一份为二 int middle = getMiddle(arr, low, high);// arr 0,9 m = 8 System.out.println(&quot;middle = &quot; + middle);//m =4 //左边进行递归 快速排序 quickSort(arr,low,middle -1); // arr 0,7 //右边进行递归 快速排序 quickSort(arr,middle + 1,high);// arr 9，9 &#125;&#125;//再次封装，对外调用 12，14public static void quick(int[] arr)&#123; if(arr.length &gt;=2) quickSort(arr, 0, arr.length -1);// 0,9&#125;int[] a =&#123;&#125;int[] a =&#123;65&#125;int[] a =&#123;65,16&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://example.com/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"}]},{"title":"正式课程1","slug":"正式课程1","date":"2021-07-15T06:40:43.000Z","updated":"2021-07-19T02:41:56.032Z","comments":true,"path":"2021/07/15/正式课程1/","link":"","permalink":"http://example.com/2021/07/15/%E6%AD%A3%E5%BC%8F%E8%AF%BE%E7%A8%8B1/","excerpt":"","text":"Java基础语法1. 标识符命名规范（见名思意）： 组成： 只能由字母、数字、下划线、美元$ ； (1)包 package : [模块分类], 字母全部都小写，网站或组织的逆序； (2)类 、接口 ：首字母大写，多个单词之间首字母大写分隔 （驼峰式命名）;不能以数字开头； (3)变量、方法： 首字母小写，多个单词之间首字母大写分隔 （驼峰式命名）;不能以数字开头； (4)常量： [值不能再发生改变的变量], 必须用final 修饰，字母全部都是大写，多个单词之间下划线_ 分隔，必须要赋值； (5)方法： 首字母小写，多个单词之间首字母大写分隔 （驼峰式命名） 可参考《阿里巴巴Java开发手册》 2.关键字 关键字 保留字 goto,const(关键字的候选人) 3.注释1234567单行注释： // 多行注释： /* * */ 文档注释： /** * */ 4.数据类型 基本数据类型(Primitive Type)：byte，short，int，long，float，double，char，boolean 引用数据类型(Reference Type)：类，接口，数组，枚举，注解 ​ 注意：转义字符如：char c1 =’\\b’; 5. 数据类型的相互转换：1)、正向的过程: 从低字节向高字节可以自动转换 （Java中的自动类型提升 ）12345byte-&gt; short-&gt; int-&gt; long-&gt; float-&gt; double 三种情况: int -&gt; float long -&gt; float long -&gt; double 特殊情况：char &lt;-&gt; int （相互转换） 2)、 反向的过程: 从高字节向低字节可以强制转换. 例如: int a = (int) 4.562; 注意: 反向转换将会丢失精度 6 . 运算符与操作符算术运算符 赋值运算符 比较运算符 逻辑运算符 位运算符 类型相关运算符 instance of 注意：1234int a = 10;c = a++ // c = a =10 ; a= a+1 =11c = ++a; // a= a+1 =11; c = 11;就近原则 &amp; | (1)算术运算： 0 &amp; 1 = 0 1 &amp; 0 = 0 1 * 1 = 1 0 &amp; 0 = 0 0 | 1 = 1 1 |0 = 1 1 | 1 = 1 0 | 0 = 0 示例： 3 &amp; 2 = 2； 3 | 2 = 3； （2）逻辑运算 (exp1) &amp; (exp2) : 两个条件必须同时满足,才为true true &amp; true = true; true &amp; false = false; false &amp; true = false; false &amp; false = false; (exp1) | (exp2) : 两个条件有一个为true,值为true true | true = true; true | false = false; false | true = false; false | false = false; 短路与&amp;&amp;， 短路或||12345678910 (exp1) &amp;&amp; (exp2) : 两个条件必须同时满足,才为true true &amp;&amp; true = true;true &amp;&amp; false = false;false &amp;&amp; true = false;false &amp;&amp; false = false; (exp1) || (exp2) : 两个条件有一个为true,值为true true || true = true; true || false = false; false || true = false; false || false = false; 总结 &amp;&amp; 和 &amp; 的区别 ， || 和 | 的区别1234567 (exp1) &amp; (exp2) : exp1,exp2 都要执行 (exp1) | (exp2) : exp1,exp2 都要执行 (exp1) &amp;&amp; (exp2) &amp;&amp; （exp3） 若exp1 表达式返回false， exp2不执行，直接返回结果false(exp1) || (exp2) 若exp1 表达式返回true， exp2不执行，直接返回结果true 7. 流程控制（1）顺序结构 if-else 12345678910111213 if (逻辑表达式) &#123; 语句1； 语句2； …… &#125; if (逻辑表达式)&#123; 语句； &#125;else&#123; 语句； &#125; switch-case switch与case后面的值的数据类型： (能够转换成int类型的值)byte,short,int,char, Byte,Short,Integer,Character, + String + 枚举 123456789101112131415switch(表达式)&#123; case 常量表达式1：语句1 case 常量表达式2：语句2 ...... case 常量表达式n：语句n default: 语句n+1&#125;//case块中不加break时顺序执行下面的语句int day =20;switch( day )&#123; case 1: System.out.println(&quot;星期1&quot;);break; case 2: System.out.println(&quot;星期2&quot;);break; default: System.out.println(&quot;无效的星期&quot;);break;&#125; （2）循环结构 while 123456789while( 逻辑表达式 )&#123; // 返回true才继续循环执行代码块 //代码块&#125;int i =1;while(i&lt;=10)&#123; System.out.print(i); i++;&#125; do-while 12345678910111213do&#123; //代码块&#125;while( 逻辑表达式 )&#123; // 返回true才继续循环执行代码块 示例： int i =0; do&#123; System.out.println(i); i++;&#125; while(i&lt;=10)； for循环 12345for(int i =0;i&lt;10;i++)&#123; // 0-9 System.out.println(i);&#125; 循环嵌套 12345678910111213141516171819202122232425for(int i =1;i&lt;=3;i++)&#123; for(int j =1;j&lt;=2 ;j++)&#123; int m = i * j ; System.out.println(m); &#125; &#125;/* i = 1;i&lt;= 3; true; int j =1; j&lt;=2 true; m = 1*1 = 1; print(m) 1 ; j++ j = 2; j&lt;=2 true; m = 1* 2 = 2; print(m) 2 ;j++ j= 3;j&lt;=2 false 内存循环就结束 i= 2;i&lt;=3 true; int j = 1;j&lt;=2 m =2 *1 = 2 ;j++ j = 2; j&lt;=2 m = 2*2 = 4;j++ j = 3 j&lt;=2 false 内存循环就结束 i= 3; i&lt;=3 true int j = 1;j&lt;=2 m =3 *1 = 3 ;j++ j = 2; j&lt;=2 m = 3*2 = 6;j++ j = 3 j&lt;=2 false 内存循环就结束 i = 4 ; i&lt;=3 false 该循环结束*/ 循环中的关键字 break,continue break : 结束当前循环 continue ： 结束本次循环，继续下一次循环 8.数组一维数组定义：一组相同数据类型数据的集合; 内存地址连续； 长度固定； 下标从0开始 （1）声明数组变量123 数组能以下列形式声明： （数据类型 变量名）int[] myArray ；Product[] proArray ； (2)数组的定义 int[] a =new int[10](数组空间的声明，并把空间首地址赋值给数组的引用) int[] a； a=new int[10]； Product[] proArray = new Product[100]; 上面的语法语句做了两件事: a. 创建了Product类型的，长度为100的数组。 b. 把新创建的数组的引用赋值给变量 proArray 。 (3) 数组创建后有初始值: 整型类型为0 浮点型为0.0 布尔类型为false 字符类型&#39;&#39; 引用类型为null (4)访问数组中的元素 a[8] //访问a数组中下标为8的元素值 (5)获得数组的长度1a.length 注意: 访问没有初始化的数组中的值，是会抛出异常的(NullPointerException）, Java中只保证一维数组的地址是连续的，二维数组实际上是一维数组中有存储了一维数组的引用。 练习：将10个任意小数放置数组中，并将其累加获得总和；获得数组中最大值。foreach循环（JDK1.5引进） (5)数组默认值123boolean[] a = new boolean[5];里面的值默认为false 9. 二维数组(1)二维数组定义：（中药店的药柜，电影院的座位）1234567891011121314dataType[][] arrayName = new arrayName[rows][columns];int[][] arr = new int[3][4];//定义了一个存放整型数据的数组，3行4列（即包含三个一维数组，每个一维数组中可以存储4个整数）arr[0][0] = 18;arr[0][1] = 17;arr[0][2] = 33;arr[0][3] = 6;arr[1][0] = 99;arr[1][1] = 23;arr[1][2] = 56;arr[1][3] = 91;arr[2][0] = 76;arr[2][1] = 10;arr[2][2] = 4;arr[2][3] = 7; (2)获得二维数组的长度：arr.length : 获得该二维数组共有几行（共有几个一维数组） arr[0].length:获得该二维数组共有几列（每个一维数组有几个值） (3)Arrays 类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 练习：数组中查询最大值，最小值，排序 ​ ​","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://example.com/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"}]},{"title":"idea快捷键（部分）","slug":"idea快捷键","date":"2021-07-15T05:32:18.000Z","updated":"2021-07-15T07:08:07.340Z","comments":true,"path":"2021/07/15/idea快捷键/","link":"","permalink":"http://example.com/2021/07/15/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"Ctrl 快捷键 介绍 Ctrl + F 在当前文件进行文本查找 Ctrl + R 在当前文件进行文本替换 Ctrl + Z 撤销 Ctrl + Y 删除光标所在行 或 删除选中的行 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为Ctrl + 逗号 Ctrl + O 查看我们继承的类或者接口中的方法，以及我们要实现的方法 Alt 快捷键 介绍 Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 Alt + Insert set/get; 构造方法; toString; 重写方法。。。 Ctrl+Alt 快捷键 介绍 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 Ctrl + Alt + 左方向键 退回到上一个操作的地方 Ctrl + Alt + 右方向键 前进到上一个操作的地方 Ctrl + Alt + T 将代码包在一个块中，例如try/catch ;synchronized等 Ctrl+Shift 快捷键 介绍 Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 Ctrl + Shift + J 自动将下一行合并到当前行末尾 Ctrl + Shift + Z 取消撤销 Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 Ctrl + Shift + / 代码块注释 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 快速打印语句 psvm 或者 main 12public static void main(String[] args) &#123;&#125; sout，soutm, soutp 和 soutv 1234System.out.println();System.out.println(&quot;Main.main&quot;);System.out.println(&quot;args = &quot; + Arrays.deepToString(args));System.out.println(&quot;args = &quot; + args); fori 12for (int i = 0; i &lt; ; i++) &#123; &#125;","categories":[{"name":"idea","slug":"idea","permalink":"http://example.com/categories/idea/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://example.com/tags/idea/"}]},{"title":"day01课堂笔记的更新版本","slug":"day02","date":"2021-07-13T06:49:41.000Z","updated":"2021-07-13T06:53:35.421Z","comments":true,"path":"2021/07/13/day02/","link":"","permalink":"http://example.com/2021/07/13/day02/","excerpt":"","text":"hexo+github搭建博客服务器 csdn,简书,有道笔记 - 广告比较多 hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/阿里云服务器 安装nodejs 非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的] D:/node-v14.17.3-win-x64 环境变量的配置 桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N) 定位到下方的系统变量 定位到变量名 - Path - 编辑 - 新建 D:/node-v14.17.3-win-x64 一定要关闭所有的环境变量配置的窗口 - 确定 打开终端[如果终端已经打开了,关闭 - 重新打开] win[微软图标]+r - 输入cmd - 输入如下指令检测nodejs是否配置成功 12345npm -v6.14.5 出现版本号,则说明配置成功 如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否成功配置到了path中 简单认识npm npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具. 通过npm可以安装,共享,分发代码,管理项目依赖关系. 类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具] npm简单使用修改镜像 为了下载速度变快,修改npm的镜像 1npm config set registry https://registry.npm.taobao.org 验证一下,镜像是否成功修改了 123npm config get registryhttps://registry.npm.taobao.org/ 简单使用 - 不需要操作 下载bootstrap npm install 框架名称 - 默认下载的是最新的版本 1npm install bootstrap@3 Hexo官网 https://hexo.io/zh-cn/docs/ 安装 假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录] win+r - 打开终端 通过dos命令进入到hello-hexo目录中 123C:/User/admin&gt;d:D:&gt;cd hello-hexoD:/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录1D:/hello-hexo&gt;hexo init hello-blog 12cd hello-blogD:/hello-hexo/hello-blog&gt;npm install 测试 - 启动博客服务器1D:/hello-hexo/hello-blog&gt;hexo s 关闭服务器 1ctrl+c 打开浏览器输入:localhost:4000 常用主题模板 https://blog.csdn.net/zgd826237710/article/details/99671027 使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,重新打开终端 1git --version 注册码云账号 推荐用QQ注册一下 本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下 C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容 1[user] email = 码云的QQ邮箱 name = 用户名 安装模板 通过cmd进入到hello-blog目录中的themes目录中 1D:/hello-hexo/hello-blog&gt;cd themesD://hello-hexo/hello-blog/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 或者直接从github上直接clone 1git clone https://github.com/cofess/hexo-theme-pure.git 更新主题配置 指定新的主题 hello-blog目录下的_config.yml文件 1theme: hexo-theme-pure 重启服务器hexo s 个人信息hexo-theme-pure/_config.yml文件 1overriden author: 亲爱的管管 author_title: 高级打字员 author_description: 个人简介。 location: SuZhou, China Markdown语法 语法的编辑器 - https://typora.io/ 文件的后缀是md 1常用语法如下:1. 标题的语法:1~6标题 - # 一级标题 ## 二级标题 2. 代码块 - java,js,mysql...​~~~java 敲enter键3. 列表3-1. 无序列表 * 列表名称 有序列表 1. 列表名称4. 高亮显示 `高亮显示内容`5. 加粗字体 **粗体**6. 斜体 *斜体*7. 粗+斜 ***粗斜***8. 段落 &gt; 空格9. 引入外部图片 ![](xx.png)10. 表格 新建博文1D://hello-hexo/hello-blog&gt;hexo n java 效果:hello-blog目录下的source/_ports/自动生成一个java.md文件 重启blog服务器 1D://hello-hexo/hello-blog&gt;hexo s 主题的侧边栏 侧边栏的链接生效 将/hello-blog/themes/hexo-theme-pure/_source/下的除了_data文件夹,其余文件夹 拷贝一份放入到hello-blog目录下的source目录中即可 文章的分类和标签 只需要在文章的.md文件的自动生成的头部添加 1title: javadate: 2021-07-13 08:44:42categories: javatags: java 博客的语言环境设置 设置中文 hello-blog下的_config.yml文件中 language: zh-CN 图片显示问题 安装插件 - npm install https://gitee.com/guancg/hexo-asset-image.git –save 需要到hello-blog/_config.yml文件中进行配置 1post_asset_folder: true hexo n 机器学习 效果就是除了生成了机器学习.md还有一个机器学习文件夹,那么这篇文章的所有的图片就可以存储在机器学习文件夹中 hexo s 内置搜索的功能 1# Searchsearch:insight: true # you need to install `hexo-generator-json-content` before using Insight Searchbaidu: false # you need to disable other search engines to use Baidu search 安装内置搜索插件 npm i -S hexo-generator-json-content 评论 不需要本地数据库进行存储的,用的是第三方的. LeanCloud - 官网地址 - https://www.leancloud.cn/ 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 appId - sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz appKey - 3hn4ijEgSzJeRV4nkmXThmGV 在hexo-theme-pure\\_config.yml文件中配置 1valine: # Valine. https://valine.js.org appid: sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz # your leancloud application appid appkey: 3hn4ijEgSzJeRV4nkmXThmGV# your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # Article reading statistic https://valine.js.org/visitor.html #字数统计&amp;阅读时长 npm i -S hexo-wordcount hexo-theme-pure_config.yml文件中配置 1postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 附件-优秀插件 显示图片 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 内置搜索 1npm i -S hexo-generator-json-content 字数统计&amp;阅读时长 1npm i -S hexo-wordcount github部署 1npm install hexo-deployer-git --save github注册一下 github.com chrome浏览器 + iguge - https://iguge.app/ 新建的仓库的名称必须是guancgsuccess.github.io 仓库地址 - https://github.com/guancgsuccess/guancgsuccess.github.io.git 安装github部署插件 npm install hexo-deployer-git –save hello-blog/_config.yml文件 1deploy:type: &#x27;git&#x27;repo: &#x27;https://github.com/guancgsuccess/guancgsuccess.github.io.git&#x27;branch: &#x27;master&#x27; hexo三连操作 1hexo clhexo ghexo shexo d 浏览器输入 - guancgsuccess.github.io","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"将hexo部署到github","slug":"将hexo部署到github","permalink":"http://example.com/tags/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"}]},{"title":"英雄联盟","slug":"lol","date":"2021-07-13T01:21:13.000Z","updated":"2021-07-13T05:39:26.442Z","comments":true,"path":"2021/07/13/lol/","link":"","permalink":"http://example.com/2021/07/13/lol/","excerpt":"","text":"登录免费送皮肤 点击 https://lol.qq.com/act/a20210709sentinel/main.html?e_code=507042 进入游戏主页 登录游戏账号 领取免费冠军皮肤 如果你这么做了的话就说明 你被我骗了 就问你 气不气","categories":[],"tags":[{"name":"冠军皮肤免费领取","slug":"冠军皮肤免费领取","permalink":"http://example.com/tags/%E5%86%A0%E5%86%9B%E7%9A%AE%E8%82%A4%E5%85%8D%E8%B4%B9%E9%A2%86%E5%8F%96/"}]},{"title":"huya","slug":"huya","date":"2021-07-13T01:08:16.000Z","updated":"2021-07-13T01:26:17.659Z","comments":true,"path":"2021/07/13/huya/","link":"","permalink":"http://example.com/2021/07/13/huya/","excerpt":"","text":"","categories":[],"tags":[{"name":"huya","slug":"huya","permalink":"http://example.com/tags/huya/"}]},{"title":"day01课堂笔记","slug":"day01","date":"2021-07-12T08:59:24.000Z","updated":"2021-07-13T00:54:36.140Z","comments":true,"path":"2021/07/12/day01/","link":"","permalink":"http://example.com/2021/07/12/day01/","excerpt":"","text":"hexo+github搭建博客服务器 csdn,简书,有道笔记 - 广告比较多 hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/阿里云服务器 安装nodejs 非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的] D:/node-v14.17.3-win-x64 环境变量的配置 桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N) 定位到下方的系统变量 定位到变量名 - Path - 编辑 - 新建 D:/node-v14.17.3-win-x64 一定要关闭所有的环境变量配置的窗口 - 确定 打开终端[如果终端已经打开了,关闭 - 重新打开] win[微软图标]+r - 输入cmd - 输入如下指令检测nodejs是否配置成功 12345npm -v6.14.5 出现版本号,则说明配置成功 如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否成功配置到了path中 简单认识npm npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具. 通过npm可以安装,共享,分发代码,管理项目依赖关系. 类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具] npm简单使用修改镜像 为了下载速度变快,修改npm的镜像 1npm config set registry https://registry.npm.taobao.org 验证一下,镜像是否成功修改了 123npm config get registryhttps://registry.npm.taobao.org/ 简单使用 - 不需要操作 下载bootstrap npm install 框架名称 - 默认下载的是最新的版本 1npm install bootstrap@3 Hexo官网 https://hexo.io/zh-cn/docs/ 安装 假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录] win+r - 打开终端 通过dos命令进入到hello-hexo目录中 123C:/User/admin&gt;d:D:&gt;cd hello-hexoD:/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录1D:/hello-hexo&gt;hexo init hello-blog 12cd hello-blogD:/hello-hexo/hello-blog&gt;npm install 测试 - 启动博客服务器1D:/hello-hexo/hello-blog&gt;hexo s 关闭服务器 1ctrl+c 打开浏览器输入:localhost:4000 常用主题模板 https://blog.csdn.net/zgd826237710/article/details/99671027 使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,重新打开终端 1git --version 注册码云账号 推荐用QQ注册一下 本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下 C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容 1[user] email = 码云的QQ邮箱 name = 用户名 安装模板 通过cmd进入到hello-blog目录中的themes目录中 1D:/hello-hexo/hello-blog&gt;cd themesD://hello-hexo/hello-blog/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 或者直接从github上直接clone 1git clone https://github.com/cofess/hexo-theme-pure.git 更新主题配置 指定新的主题 hello-blog目录下的_config.yml文件 1theme: hexo-theme-pure 重启服务器hexo s Markdown语法 语法的编辑器 - https://typora.io/ 文件的后缀是md 1常用语法如下:1. 标题的语法:1~6标题 - # 一级标题 ## 二级标题 2. 代码块 - java,js,mysql...​~~~java 敲enter键3. 列表3-1. 无序列表 * 列表名称 有序列表 1. 列表名称4. 高亮显示 `高亮显示内容`5. 加粗字体 **粗体**6. 斜体 *斜体*7. 粗+斜 ***粗斜***8. 段落 &gt; 空格9. 引入外部图片 ![](xx.png)10. 表格 新建博文1D://hello-hexo/hello-blog&gt;hexo n java 效果:hello-blog目录下的source/_ports/自动生成一个java.md文件 重启blog服务器 1D://hello-hexo/hello-blog&gt;hexo s","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"idea","slug":"idea","permalink":"http://example.com/categories/idea/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://example.com/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"name":"idea","slug":"idea","permalink":"http://example.com/tags/idea/"},{"name":"将hexo部署到github","slug":"将hexo部署到github","permalink":"http://example.com/tags/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"},{"name":"冠军皮肤免费领取","slug":"冠军皮肤免费领取","permalink":"http://example.com/tags/%E5%86%A0%E5%86%9B%E7%9A%AE%E8%82%A4%E5%85%8D%E8%B4%B9%E9%A2%86%E5%8F%96/"},{"name":"huya","slug":"huya","permalink":"http://example.com/tags/huya/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}